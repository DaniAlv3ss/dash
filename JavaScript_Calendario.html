<script>
// ==================================================================
// === NOVA LÓGICA DO MODAL DE CALENDÁRIO (DESENVOLVIDA DO ZERO) ===
// ==================================================================

(function() {
    // --- Variáveis de Estado ---
    let currentDisplayDate = new Date(); // Mês/Ano atualmente exibido
    let eventsDataCache = {}; // Cache de eventos por mês {'YYYY-MM': { 'YYYY-MM-DD': [event] }}
    let selectedDateStr = null; // Data selecionada no formato 'YYYY-MM-DD'

    // --- Elementos DOM (cache para performance) ---
    let elements = {};

    /**
     * Inicializa o modal, busca elementos DOM e adiciona event listeners.
     * Esta função é chamada pelo script principal em Index.html.
     */
    function initializeCalendarModal() {
        console.log("Inicializando Modal do Calendário...");
        cacheDOMElements(); // Busca e armazena referências aos elementos DOM

        if (!elements.openBtn || !elements.modal || !elements.closeBtn || !elements.prevMonthBtn || !elements.nextMonthBtn || !elements.calendarGrid) {
            console.error("ERRO: Elementos essenciais do modal do calendário não encontrados no DOM. A funcionalidade pode não operar.");
            return; // Interrompe se elementos cruciais faltarem
        }

        // --- Event Listeners ---
        elements.openBtn.addEventListener('click', openModal);
        elements.closeBtn.addEventListener('click', closeModal);
        elements.modal.addEventListener('click', (e) => { // Fechar ao clicar fora
            if (e.target === elements.modal) {
                closeModal();
            }
        });
        elements.prevMonthBtn.addEventListener('click', () => changeMonth(-1));
        elements.nextMonthBtn.addEventListener('click', () => changeMonth(1));
        elements.calendarGrid.addEventListener('click', handleDayClick);

        console.log("Modal do Calendário inicializado com sucesso.");
    }

    /**
     * Busca e armazena referências aos elementos DOM necessários.
     */
    function cacheDOMElements() {
        elements = {
            openBtn: document.getElementById('open-calendar-modal-btn'),
            modal: document.getElementById('calendar-modal'),
            modalContent: document.getElementById('calendar-modal-content'),
            closeBtn: document.getElementById('calendar-modal-close'),
            prevMonthBtn: document.getElementById('calendar-prev-month'),
            nextMonthBtn: document.getElementById('calendar-next-month'),
            monthYearDisplay: document.getElementById('calendar-month-year'),
            calendarGrid: document.getElementById('calendar-grid'),
            loader: document.getElementById('calendar-loader'),
            eventSidebar: document.getElementById('calendar-event-sidebar'),
            eventListTitle: document.getElementById('event-list-title'),
            eventListContainer: document.getElementById('calendar-event-list')
        };
    }

    // --- Funções de Controle do Modal ---

    /**
     * Abre o modal do calendário.
     */
    function openModal() {
        console.log("Abrindo modal...");
        currentDisplayDate = new Date(); // Reseta para o mês atual
        selectedDateStr = null; // Limpa seleção
        updateCalendarView(); // Renderiza o calendário e busca eventos

        elements.modal.classList.remove('hidden');
        elements.modal.classList.add('flex');
        // Força reflow para transição
        void elements.modal.offsetWidth;
        elements.modal.classList.remove('opacity-0');
        elements.modalContent.classList.remove('scale-95', 'opacity-0');
        elements.modalContent.classList.add('scale-100', 'opacity-100');
    }

    /**
     * Fecha o modal do calendário.
     */
    function closeModal() {
        console.log("Fechando modal...");
        elements.modal.classList.add('opacity-0');
        elements.modalContent.classList.add('scale-95', 'opacity-0');
        elements.modalContent.classList.remove('scale-100', 'opacity-100');
        setTimeout(() => {
            elements.modal.classList.add('hidden');
            elements.modal.classList.remove('flex');
            // Limpa o conteúdo da sidebar ao fechar para evitar mostrar dados antigos na próxima abertura
            if (elements.eventListContainer) elements.eventListContainer.innerHTML = '<div class="no-events">Nenhum dia selecionado.</div>';
            if (elements.eventListTitle) elements.eventListTitle.textContent = 'Selecione um dia';
        }, 300); // Duração da transição CSS
    }

    // --- Funções de Navegação e Atualização do Calendário ---

    /**
     * Muda o mês exibido no calendário.
     * @param {number} direction -1 para mês anterior, 1 para próximo mês.
     */
    function changeMonth(direction) {
        currentDisplayDate.setMonth(currentDisplayDate.getMonth() + direction);
        selectedDateStr = null; // Limpa seleção ao mudar de mês
        updateCalendarView();
    }

    /**
     * Atualiza a exibição do calendário (renderiza grid e busca eventos).
     */
    function updateCalendarView() {
        console.log(`Atualizando calendário para: ${currentDisplayDate.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' })}`);
        renderCalendarGrid(); // Desenha a estrutura do calendário
        fetchEventsForMonth(); // Busca os eventos para o mês atual
    }

    /**
     * Renderiza a grade de dias do calendário no DOM.
     */
    function renderCalendarGrid() {
        if (!elements.calendarGrid || !elements.monthYearDisplay || !elements.loader) return;

        showLoader(true); // Mostra o loader
        elements.calendarGrid.innerHTML = ''; // Limpa o grid

        const year = currentDisplayDate.getFullYear();
        const month = currentDisplayDate.getMonth(); // 0-indexed

        elements.monthYearDisplay.textContent = currentDisplayDate.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });

        const firstDayOfMonth = new Date(year, month, 1);
        const lastDayOfMonth = new Date(year, month + 1, 0);
        const firstDayWeekday = firstDayOfMonth.getDay(); // 0 (Dom) a 6 (Sáb)
        const totalDaysInMonth = lastDayOfMonth.getDate();

        const today = new Date();
        const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        // Dias do mês anterior
        const daysInPrevMonth = new Date(year, month, 0).getDate();
        for (let i = 0; i < firstDayWeekday; i++) {
            const day = daysInPrevMonth - firstDayWeekday + 1 + i;
            elements.calendarGrid.appendChild(createDayElement(day, true));
        }

        // Dias do mês atual
        for (let day = 1; day <= totalDaysInMonth; day++) {
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            elements.calendarGrid.appendChild(
                createDayElement(day, false, dateStr, dateStr === todayStr, dateStr === selectedDateStr)
            );
        }

        // Dias do próximo mês
        const totalCellsFilled = firstDayWeekday + totalDaysInMonth;
        const remainingCells = (7 - (totalCellsFilled % 7)) % 7;
        for (let i = 1; i <= remainingCells; i++) {
            elements.calendarGrid.appendChild(createDayElement(i, true));
        }
    }

    /**
     * Cria um elemento div para representar um dia no calendário.
     * @param {number} day - O número do dia.
     * @param {boolean} isOtherMonth - Indica se o dia pertence ao mês anterior/seguinte.
     * @param {string} [dateStr] - A data no formato 'YYYY-MM-DD' (apenas para dias do mês atual).
     * @param {boolean} [isToday] - Indica se é o dia atual.
     * @param {boolean} [isSelected] - Indica se é o dia selecionado.
     * @returns {HTMLDivElement} O elemento div do dia.
     */
    function createDayElement(day, isOtherMonth, dateStr = '', isToday = false, isSelected = false) {
        const dayDiv = document.createElement('div');
        dayDiv.className = 'calendar-day';
        if (isOtherMonth) {
            dayDiv.classList.add('other-month');
        } else {
            dayDiv.dataset.date = dateStr; // Adiciona data apenas para dias clicáveis
            if (isToday) dayDiv.classList.add('today');
            if (isSelected) dayDiv.classList.add('selected');
            // Adiciona container para os pontos de evento
            dayDiv.innerHTML = `<span>${day}</span><div class="day-event-dots" id="dots-${dateStr}"></div>`;
        }
        if (!dayDiv.innerHTML) { // Adiciona o número do dia se não houver pontos
             dayDiv.innerHTML = `<span>${day}</span>`;
        }
        return dayDiv;
    }

    /**
     * Lida com o clique em um dia do calendário.
     * @param {Event} event - O objeto do evento de clique.
     */
    function handleDayClick(event) {
        const dayElement = event.target.closest('.calendar-day:not(.other-month)');
        if (dayElement && dayElement.dataset.date) {
            const dateStr = dayElement.dataset.date;
            console.log(`Dia clicado: ${dateStr}`);
            selectDay(dateStr, dayElement);
        }
    }

    /**
     * Seleciona um dia, atualiza a interface e a lista de eventos.
     * @param {string} dateStr - A data selecionada ('YYYY-MM-DD').
     * @param {HTMLElement} dayElement - O elemento do dia que foi clicado.
     */
    function selectDay(dateStr, dayElement) {
        // Remove seleção anterior visualmente
        const previouslySelected = elements.calendarGrid.querySelector('.calendar-day.selected');
        if (previouslySelected) {
            previouslySelected.classList.remove('selected');
        }

        // Adiciona seleção visual ao novo dia
        dayElement.classList.add('selected');
        selectedDateStr = dateStr;

        // Renderiza a lista de eventos para o dia selecionado
        renderEventList(dateStr);
    }

    // --- Funções de Busca e Exibição de Eventos ---

    /**
     * Busca os eventos para o mês atualmente exibido no calendário.
     */
    function fetchEventsForMonth() {
        const year = currentDisplayDate.getFullYear();
        const month = currentDisplayDate.getMonth() + 1; // Backend usa 1-12
        const cacheKey = `${year}-${String(month).padStart(2, '0')}`;

        // Verifica se os dados já estão no cache
        if (eventsDataCache[cacheKey]) {
            console.log(`Eventos carregados do cache para ${cacheKey}`);
            processFetchedEvents(eventsDataCache[cacheKey]);
            showLoader(false); // Esconde o loader após renderizar a grade e processar cache
            return;
        }

        console.log(`Buscando eventos do servidor para ${cacheKey}...`);
        showLoader(true); // Garante que o loader está visível
        if (elements.eventListContainer) elements.eventListContainer.innerHTML = '<div class="no-events">Carregando eventos...</div>';
        if (elements.eventListTitle) elements.eventListTitle.textContent = "Carregando...";

        google.script.run
            .withSuccessHandler(data => {
                console.log(`Eventos recebidos para ${cacheKey}`);
                if (typeof data === 'object' && data !== null && !data.error) {
                    eventsDataCache[cacheKey] = data; // Armazena no cache
                    processFetchedEvents(data);
                } else {
                    handleFetchError(data?.error || "Resposta inválida do servidor.");
                }
                showLoader(false); // Esconde o loader após processar
            })
            .withFailureHandler(error => {
                console.error(`Falha ao buscar eventos para ${cacheKey}:`, error);
                handleFetchError(error.message || "Erro desconhecido.");
                showLoader(false); // Esconde o loader em caso de falha
            })
            .getCalendarEventsWithCache(year, month);
    }

    /**
     * Processa os dados de eventos recebidos do servidor e adiciona os pontos visuais.
     * @param {object} events - Objeto com eventos agrupados por data ('YYYY-MM-DD').
     */
    function processFetchedEvents(events) {
        // Limpa pontos antigos (caso haja re-renderização sem recarregar dados)
        elements.calendarGrid.querySelectorAll('.day-event-dots').forEach(dotsContainer => {
            dotsContainer.innerHTML = '';
        });

        // Adiciona novos pontos
        Object.keys(events).forEach(dateStr => {
            const dotsContainer = elements.calendarGrid.querySelector(`#dots-${dateStr}`);
            if (dotsContainer) {
                const dayEvents = events[dateStr] || [];
                const hasAcao = dayEvents.some(e => e.type === 'acao');
                const hasCalendario = dayEvents.some(e => e.type === 'calendario');

                if (hasAcao) {
                    dotsContainer.innerHTML += '<div class="event-dot event-dot-acao"></div>';
                }
                if (hasCalendario) {
                    dotsContainer.innerHTML += '<div class="event-dot event-dot-calendario"></div>';
                }
            }
        });

        // Atualiza a sidebar se um dia estiver selecionado
        if (selectedDateStr) {
            renderEventList(selectedDateStr);
        } else {
            renderEventList(null); // Mostra estado inicial da sidebar
        }
    }

    /**
     * Renderiza a lista de eventos na sidebar para a data fornecida.
     * @param {string | null} dateStr - A data no formato 'YYYY-MM-DD' ou null.
     */
    function renderEventList(dateStr) {
        if (!elements.eventListContainer || !elements.eventListTitle) return;

        elements.eventListContainer.innerHTML = ''; // Limpa antes de popular

        if (!dateStr) {
            elements.eventListTitle.textContent = 'Selecione um dia';
            elements.eventListContainer.innerHTML = '<div class="no-events">Nenhum dia selecionado.</div>';
            return;
        }

        try {
            const displayDate = new Date(dateStr + 'T00:00:00'); // Garante que a data seja interpretada localmente
            elements.eventListTitle.textContent = `Eventos de ${displayDate.toLocaleDateString('pt-BR', { day: '2-digit', month: 'long' })}`;
        } catch (e) {
            console.error("Erro ao formatar data para título da lista:", e);
            elements.eventListTitle.textContent = "Eventos";
        }

        const monthCacheKey = dateStr.substring(0, 7); // 'YYYY-MM'
        const eventsForDay = (eventsDataCache[monthCacheKey] && eventsDataCache[monthCacheKey][dateStr]) ? eventsDataCache[monthCacheKey][dateStr] : [];

        if (eventsForDay.length === 0) {
            elements.eventListContainer.innerHTML = '<div class="no-events">Nenhum evento para este dia.</div>';
            return;
        }

        eventsForDay.forEach(event => {
            elements.eventListContainer.appendChild(createEventItemElement(event));
        });
    }

    /**
     * Cria o elemento HTML para um item de evento na lista.
     * @param {object} event - O objeto do evento.
     * @returns {HTMLDivElement} O elemento div do item de evento.
     */
    function createEventItemElement(event) {
        const itemDiv = document.createElement('div');
        itemDiv.className = `event-item ${event.type === 'acao' ? 'event-item-acao' : 'event-item-calendario'}`;

        let timeHtml = '';
        if (event.startTime && event.endTime) {
            timeHtml = `<span class="event-time">${event.startTime} - ${event.endTime}</span>`;
        } else if (event.startTime) {
            timeHtml = `<span class="event-time">${event.startTime}</span>`;
        }

        const summaryHtml = event.summary ? `<p class="event-summary">${escapeHtml(event.summary)}</p>` : '';
        const linksHtml = createLinksHtml(event.links);

        itemDiv.innerHTML = `
            ${timeHtml}
            <strong class="event-title">${escapeHtml(event.title)}</strong>
            ${summaryHtml}
            ${linksHtml}
        `;
        return itemDiv;
    }

    /**
     * Cria o HTML para os links de um evento, tratando diferentes formatos.
     * @param {string | null} linksString - A string contendo links, separados por vírgula.
     * @returns {string} O HTML formatado dos links.
     */
    function createLinksHtml(linksString) {
        if (!linksString) return '';

        const links = linksString.split(',')
            .map(link => link.trim())
            .filter(link => link); // Remove links vazios

        if (links.length === 0) return '';

        let html = '<div class="event-links mt-1">';
        links.forEach(link => {
            let linkName = 'Link';
            let isExternalUrl = link.startsWith('http://') || link.startsWith('https://');

            if (isExternalUrl) {
                try {
                    const url = new URL(link);
                    linkName = url.hostname.replace('www.', ''); // Nome mais amigável
                } catch (e) {
                    console.warn("URL inválida encontrada:", link);
                    linkName = "Link inválido";
                    isExternalUrl = false; // Trata como texto se não for URL válida
                }
            } else {
                linkName = link; // Usa o texto como está se não for URL
            }

            if (isExternalUrl) {
                html += `<a href="${escapeHtml(link)}" target="_blank" rel="noopener noreferrer">${escapeHtml(linkName)}</a>`;
            } else {
                // Exibe como texto simples, não clicável
                html += `<span class="non-url-link text-xs text-slate-500">${escapeHtml(linkName)}</span>`;
            }
        });
        html += '</div>';
        return html;
    }


    // --- Funções Auxiliares ---

    /**
     * Mostra ou esconde o indicador de carregamento.
     * @param {boolean} show - True para mostrar, false para esconder.
     */
    function showLoader(show) {
        if (elements.loader) {
            elements.loader.style.display = show ? 'block' : 'none';
        }
    }

    /**
     * Lida com erros ao buscar eventos do servidor.
     * @param {string} errorMessage - A mensagem de erro.
     */
    function handleFetchError(errorMessage) {
         if (elements.eventListContainer) {
            elements.eventListContainer.innerHTML = `<div class="no-events text-red-500">Falha ao carregar eventos: ${escapeHtml(errorMessage)}</div>`;
         }
         if (elements.eventListTitle) {
            elements.eventListTitle.textContent = "Erro";
         }
         // Poderia limpar os pontos do calendário aqui se desejado
         // elements.calendarGrid.querySelectorAll('.day-event-dots').forEach(el => el.innerHTML = '');
    }

     /**
     * Escapa caracteres HTML para exibição segura.
     * @param {string} str - A string a ser escapada.
     * @returns {string} A string escapada.
     */
     function escapeHtml(str) {
        if (typeof str !== 'string') return '';
        return str
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }

    // --- Inicialização ---
    // A inicialização agora é chamada pelo Index.html
    // Certifique-se de que a função initializeCalendarModal esteja acessível globalmente
    // ou que o Index.html a chame corretamente após o DOM carregar.
    window.initializeCalendarModal = initializeCalendarModal;

})(); // Fim da IIFE (Immediately Invoked Function Expression) para encapsular o escopo

</script>

